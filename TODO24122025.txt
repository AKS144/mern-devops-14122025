PHASE 1: CLEANUP & ENVIRONMENT SETUP

# 1. Stop and remove old containers
docker rm -f jenkins-server 2>$null
docker network rm devops-net 2>$null

# 2. Reset Minikube (Fresh Cluster)
minikube delete --all
minikube start --driver=docker --memory 8192 --cpus 4

# 3. Enable Ingress
minikube addons enable ingress

# 4. Create a dedicated Network so Jenkins can see Minikube
docker network create devops-net
docker network connect devops-net minikube



PHASE 2: PROJECT DIRECTORY & CODE

1. Create Directory Structure
New-Item -Path "C:\devops-project" -ItemType "directory" -Force
cd "C:\devops-project"
New-Item -Path "backend", "frontend", "k8s-helm\templates", "terraform", "ansible" -ItemType "directory" -Force


terraform/main.tf
terraform {
  required_providers { kubernetes = { source = "hashicorp/kubernetes" } }
}
variable "kube_config" { type = string }
provider "kubernetes" { config_path = var.kube_config }
resource "kubernetes_namespace_v1" "mern_ns" {
  metadata { name = "mern-namespace" }
}



3. ansible/inventory.ini
[local]
localhost ansible_connection=local

4.ansible/secrets.yaml
- name: Deploy Secrets
  hosts: localhost
  connection: local
  tasks:
    - name: Create MERN Secrets
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata: { name: mern-secrets, namespace: mern-namespace }
          type: Opaque
          data:
            mongo-root-password: "cGFzc3dvcmQxMjM="
            mongo-keyfile: "bXlzZWNyZXRrZXlmb3Jtb25nbzEyMw=="
            jwt-secret: "c3VwZXJzZWNyZXQ="


5. backend/Dockerfile
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["node", "server.js"]


6.frontend/Dockerfile
FROM node:16-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
ENV DISABLE_ESLINT_PLUGIN=true
RUN npx react-scripts build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html

# FIXED NGINX CONFIG FOR API PROXY
RUN echo 'server { \
  listen 80; \
  location / { \
    root /usr/share/nginx/html; \
    index index.html; \
    try_files $uri /index.html; \
  } \
  location /api/ { \
    proxy_pass http://backend-service:5000/; \
  } \
}' > /etc/nginx/conf.d/default.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]


7.k8s-helm/values.yaml
replicaCount: 3
backend:
  image: abhi144k/mern-backend
  tag: "latest"
  port: 5000
frontend:
  image: abhi144k/mern-frontend
  tag: "latest"
  port: 80
mongodb:
  image: mongo:5.0
  replicas: 3
  rootUser: "admin"
  rootPassword: "password123"
  keyFileContent: "bXlzZWNyZXRrZXlmb3Jtb25nbzEyMw=="


8.k8s-helm/templates/backend-deployment.yaml
env:
        - name: MONGO_URI
          # MUST point to mern-namespace
          value: "mongodb://admin:password123@mongo-0.mongo-service.mern-namespace.svc.cluster.local:27017,mongo-1.mongo-service.mern-namespace.svc.cluster.local:27017,mongo-2.mongo-service.mern-namespace.svc.cluster.local:27017/taskmanager?authSource=admin&replicaSet=rs0"

9.k8s-helm/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata: { name: mern-secrets }
type: Opaque
data:
  mongo-root-password: {{ .Values.mongodb.rootPassword | toString | b64enc | quote }}
  mongo-keyfile: {{ .Values.mongodb.keyFileContent | b64enc | quote }}


10.Jenkinsfile
pipeline {
    agent any
    environment {
        DOCKER_CRED = credentials('dockerhub-abhi144k')
        DOCKER_USER = 'abhi144k'
    }
    stages {
        stage('Checkout') { steps { checkout scm } }
        stage('Infrastructure') {
            steps {
                withCredentials([file(credentialsId: 'k8s-kubeconfig', variable: 'KUBECONFIG')]) {
                    dir('terraform') {
                        sh 'rm -rf .terraform .terraform.lock.hcl terraform.tfstate terraform.tfstate.backup'
                        sh 'terraform init'
                        script {
                             sh "terraform import -var 'kube_config=${KUBECONFIG}' kubernetes_namespace_v1.mern_ns mern-namespace || echo 'Namespace managed'"
                        }
                        sh "terraform apply -auto-approve -var 'kube_config=${KUBECONFIG}'"
                    }
                }
            }
        }
        stage('Secrets') {
            steps {
                withCredentials([file(credentialsId: 'k8s-kubeconfig', variable: 'K8S_AUTH_KUBECONFIG')]) {
                    dir('ansible') {
                        sh 'ansible-playbook -i inventory.ini secrets.yaml'
                    }
                }
            }
        }
        stage('Build & Push') {
            steps {
                script {
                    sh 'echo $DOCKER_CRED_PSW | docker login -u $DOCKER_CRED_USR --password-stdin'
                    sh "docker build -t $DOCKER_USER/mern-backend:latest ./backend"
                    sh "docker push $DOCKER_USER/mern-backend:latest"
                    sh "docker build --no-cache -t $DOCKER_USER/mern-frontend:latest ./frontend"
                    sh "docker push $DOCKER_USER/mern-frontend:latest"
                }
            }
        }
        stage('Deploy') {
            steps {
                withCredentials([file(credentialsId: 'k8s-kubeconfig', variable: 'KUBECONFIG')]) {
                    sh "helm upgrade --install mern-app ./k8s-helm --namespace mern-namespace --set backend.image=$DOCKER_USER/mern-backend --set frontend.image=$DOCKER_USER/mern-frontend --kubeconfig $KUBECONFIG"
                }
            }
        }
    }
}



PHASE 3: BUILD CUSTOM JENKINS
$dockerfile = @"
FROM jenkins/jenkins:lts
USER root
RUN apt-get update && apt-get install -y docker.io python3-pip wget unzip curl git
RUN wget https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip && unzip terraform_1.6.0_linux_amd64.zip && mv terraform /usr/local/bin/
RUN curl -LO "https://dl.k8s.io/release/`$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" && chmod +x kubectl && mv kubectl /usr/local/bin/
RUN curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
RUN pip3 install ansible kubernetes --break-system-packages
RUN ansible-galaxy collection install kubernetes.core
RUN usermod -aG docker jenkins
USER jenkins
"@
$dockerfile | Out-File Dockerfile -Encoding ASCII

# Build & Run
docker build -t my-devops-jenkins .
docker run -d -p 9090:8080 -p 50000:50000 --name jenkins-server --network devops-net `
  -v //var/run/docker.sock:/var/run/docker.sock `
  --user root `
  my-devops-jenkins

# Wait for it to start
Start-Sleep -Seconds 20
docker exec jenkins-server cat /var/jenkins_home/secrets/initialAdminPassword




PHASE 4: CONFIGURE JENKINS & KUBECONFIG

1.Log in to Jenkins: http://localhost:9090 (Use password from output).
2.Generate Clean Config:
Run in PowerShell:
minikube update-context
kubectl config view --flatten --minify > temp.yaml
# REPLACE IP with internal docker name, Force ASCII for Ansible
(Get-Content temp.yaml) -replace 'server: https://.*', 'server: https://minikube:8443' | Out-File -FilePath kubeconfig_jenkins.yaml -Encoding ASCII
Remove-Item temp.yaml

3.Add Credentials (Manage Jenkins -> Credentials):
dockerhub-abhi144k: Username/Password (DockerHub Token).
github-access-token: Username/Password (GitHub Token).
k8s-kubeconfig: Secret File (Upload the kubeconfig_jenkins.yaml generated above).


PHASE 5: RUN PIPELINE
1.Push Code:
cd C:\devops-project
git init
git add .
git commit -m "Final MERN DevOps Setup"
git branch -M main
# Use your repo URL
git remote add origin https://github.com/AKS144/mern-devops-14122025.git
git push -u origin main

2.Jenkins: Create Pipeline Job MERN-Deploy -> Build Now.



PHASE 6: INITIALIZE DATABASE (Once Build is Green)
kubectl get pods -n mern-namespace


Run in powershell
kubectl exec -it mongo-0 -n mern-namespace -- mongosh -u admin -p password123 --authenticationDatabase admin --eval 'rs.initiate({_id: "rs0", members: [{_id: 0, host: "mongo-0.mongo-service.mern-namespace.svc.cluster.local:27017"}, {_id: 1, host: "mongo-1.mongo-service.mern-namespace.svc.cluster.local:27017"}, {_id: 2, host: "mongo-2.mongo-service.mern-namespace.svc.cluster.local:27017"}]})'

kubectl rollout restart deployment backend -n mern-namespace


PHASE 7: ACCESS & MONITOR
1. Access App (Tunnel):
kubectl port-forward svc/frontend-service 8085:80 -n mern-namespace
Go to http://localhost:8085

2. Setup Monitoring:
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
helm install monitoring prometheus-community/kube-prometheus-stack --namespace monitoring --create-namespace

3. View Grafana:
kubectl port-forward svc/monitoring-grafana 3000:80 -n monitoring

Go to http://localhost:3000 (admin/prom-operator).//both user and password 

//if password not working get from this
kubectl get secret --namespace monitoring monitoring-grafana -o jsonpath="{.data.admin-password}" | ForEach-Object { [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($_)) }

//if user not working get from this
kubectl get secret -n monitoring monitoring-grafana -o jsonpath="{.data.admin-user}" | ForEach-Object { [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($_)) }



//if password to be Reset
# Find the Grafana pod
$pod = kubectl get pods -n monitoring -l app.kubernetes.io/name=grafana -o jsonpath="{.items[0].metadata.name}"

# Reset password to 'admin'
kubectl exec -it $pod -n monitoring -c grafana -- grafana-cli admin reset-admin-password admin
User: admin
Password: admin
//



//26/12/2025 only prometheus and grafana
kubectl get svc -n monitoring

for prometheus
kubectl port-forward svc/monitoring-kube-prometheus-prometheus 9091:9090 -n monitoring


